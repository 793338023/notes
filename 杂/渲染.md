## url

## 渲染

构建 DOM 树 =》 计算样式表 =》 布局阶段 =》 图层 =》 绘制

光栅化 =》 合成 =》 显示

布局阶段
构建布局树 =》 计算布局

图层
对布局树进行分层，并生成分层树

绘制
为每个图层生成绘制列表，并将其提交到合成线程上

光栅化
合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图

合成
显示

### 重排

修改了几何位置属性，例如元素的高度，宽度等，浏览器就重新布局，解析之后的一系列子阶段，这叫重排
重排需要更新完整的渲染流水线

### 重绘

更新元素的绘制属性，例如元素的背景颜色，透明度重绘省去了布局和分层阶段，所以执行效率会比重排高效些

### 合成

避免了重排重绘的阶段，直接在非主线程上执行合成动画操作，如 transform

### 性能优化

减少重排重绘

1、css 批量处理
2、DOM 操作批量处理
3、在批量处理时避免触发强制布局更新，如获取宽高，offsetHeight，scrollHeight 等
4、优先考虑使用 transform 做动画
5、避免使用 table 布局

其实就是减少触发重排重绘次数

减少重排重绘，相当于少了渲染进程的主线程与非主线程的计算与操作，能够加快 web 展示
1、触发重排重绘的操作尽量放在一起操作，如使用 dom 设置高度与改变元素的颜色，那样就只会触发一次重排，少了一次重绘
2、像虚拟 DOM 一样，先计算出 DOM 的差异后进行一次性的提交，减少重排重绘

## 箭头函数

箭头函数没有 this,arguments,new,super,不能用作构造函数，没有 prototype，函数生成器

## 原型

每个对象都有预设属性，而函数对象有 prototype，prototype 就指向原型，而它的每个实例都共享它的属性和方法

## 原型链

原型链解决的是继承问题

每个对象都有一个原型对象，而原型对象通过 proto 指向别的原型对象，从而继承它的属性和方法，而别的原型对象也可以通过 proto 指向别的原型，一层一层指向过去，直到 proto 为 null，这就是原型链

## 跨域

JSONP

CORS 设置

iframe + document.domain 强行设置同域

iframe + location.hash 监听 hash 的变化

iframe + window.name name 在不同域还是存在，利用切换域来对 name 设置通信

postMessage 可以跨域通信的 API

websocket 本身允许跨域

代理
niginx
后台代理 如 node

其实是利用了不在客户端进行通信，而后使用同域转发到客户端的方式，因为跨域其实客户端的同源策略导致，其实请求已经发出来的，只是被客户端拦截下来的，无法响应
