## url

## 渲染

构建 DOM 树 =》 计算样式表 =》 布局阶段 =》 图层 =》 绘制

光栅化 =》 合成 =》 显示

布局阶段
构建布局树 =》 计算布局

图层
对布局树进行分层，并生成分层树

绘制
为每个图层生成绘制列表，并将其提交到合成线程上

光栅化
合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图

合成
显示

### 重排

修改了几何位置属性，例如元素的高度，宽度等，浏览器就重新布局，解析之后的一系列子阶段，这叫重排
重排需要更新完整的渲染流水线

### 重绘

更新元素的绘制属性，例如元素的背景颜色，透明度重绘省去了布局和分层阶段，所以执行效率会比重排高效些

### 合成

避免了重排重绘的阶段，直接在非主线程上执行合成动画操作，如 transform

### 性能优化

减少重排重绘

1、css 批量处理
2、DOM 操作批量处理
3、在批量处理时避免触发强制布局更新，如获取宽高，offsetHeight，scrollHeight 等
4、优先考虑使用 transform 做动画
5、避免使用 table 布局

其实就是减少触发重排重绘次数

减少重排重绘，相当于少了渲染进程的主线程与非主线程的计算与操作，能够加快 web 展示
1、触发重排重绘的操作尽量放在一起操作，如使用 dom 设置高度与改变元素的颜色，那样就只会触发一次重排，少了一次重绘
2、像虚拟 DOM 一样，先计算出 DOM 的差异后进行一次性的提交，减少重排重绘

## 箭头函数

箭头函数没有 this,arguments,new,super,不能用作构造函数，没有 prototype，函数生成器

## 原型

每个对象都有预设属性，而函数对象有 prototype，prototype 就指向原型，而它的每个实例都共享它的属性和方法

## 原型链

原型链解决的是继承问题

每个对象都有一个原型对象，而原型对象通过 proto 指向别的原型对象，从而继承它的属性和方法，而别的原型对象也可以通过 proto 指向别的原型，一层一层指向过去，直到 proto 为 null，这就是原型链

## 跨域

JSONP

CORS 设置

iframe + document.domain 强行设置同域

iframe + location.hash 监听 hash 的变化

iframe + window.name name 在不同域还是存在，利用切换域来对 name 设置通信

postMessage 可以跨域通信的 API

websocket 本身允许跨域

代理
niginx
后台代理 如 node

其实是利用了不在客户端进行通信，而后使用同域转发到客户端的方式，因为跨域其实客户端的同源策略导致，其实请求已经发出来的，只是被客户端拦截下来的，无法响应

## URL 搜索

1、地址栏进行输入，浏览器进程判断是否为关键字搜索或者是 URL 请求，如果是 URL 请求，那么就补全 URL，构建请求行，发给网络进程进行请求资源

2、网络进程查找是否有本地副本缓存，而设置客户端缓存，可以使用 Cache-control:Max-age=2000，有则直接返回，否则进行 DNS 域名解析，DNS 域名解析也是查找是否有缓存，有则直接返回信息，否则解析出 IP 与端口

3、根据 IP 端口查找对应的服务器进行 TCP 链接，若是 HTTPS，再进行 TLS 链接，然后根据 HTTP 的请求头，是否需要重定向，需要则返回 301 或 302，根据 Location 字段进行重新请求，如果不需要则判断 IF-NONE-MATCH 字段是否有更新，没有则返回 304，复用之前的资源，有更新，则重新发送资源

4、获取到资源后，TCP 四次挥手断开，而设置 Connection:keep-alive，那么它会保持链接，等下次使用，避免再次的三次握手进行链接操作

5、而网络进程获取到数据后解析响应头信息，根据 Content-type 判断使用下载管理器，还是通知浏览器进程，让渲染进程进行展示，若是流 application/octet-stream 字节流数据那么就交到下载管理器，若是 text/html 就通知浏览器进程，准备文档提交给渲染进程

6、浏览器进程根据网站是否为同站判断是否开启新的渲染进程，如 A 打开 B，而且是同站，那么就复用 A 的渲染进程，否则就开启新的渲染进程

7、让浏览器进程提交文档给渲染进程，然后渲染进程与网络进程建立管道进行数据传输，而这个时候也会去掉旧的页面，替换为新的展示页面

8、最后就是渲染流水线的过程
