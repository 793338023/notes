软件的性能通常只与代码的一小部分相关，改变其他的部分往往对总 体性能贡献甚微。

因此对于重构过程的性能问题，我总体的建议是:大多数情况下可以忽略它。如果重构引入了性能损耗，先完成重构，再做性能优化。

营地法则:保证你离开时的代码库一定比来时更健康。

代码的重构与新特性，它们之间有时需要权衡，

现在主流的 JS Engine 是苹果的 JavaScriptCore 和谷歌的 V8，主流的渲染引擎是苹果的 Webkit 和谷歌的 Blink

有些人试图用“整洁的代码”“良好的工程实践”之类道德理由来论证重构的必 要性，我认为这是个陷阱。重构的意义不在于把代码库打磨得闪闪发光，而是纯 粹经济角度出发的考量。我们之所以重构，因为它能让我们更快——添加功能更 快，修复 bug 更快。一定要随时记住这一点，与别人交流时也要不断强调这一 点。重构应该总是由经济利益驱动。程序员、经理和客户越理解这一点，“好的 设计”那条曲线就会越经常出现。

有了重构技术，我就可以采取不同的策略。与其猜测未来需要哪些灵活性、 需要什么机制来提供灵活性，我更愿意只根据当前的需求来构造软件，同时把软 件的设计质量做得很高。

增量式设计

赞同科技
自主研发的组件平台 ide，实现界面化拖拽组件，光有架子，但布局系统没有第一时间考虑做好，先有其他组件，再有布局组件，设计不当，拖拽出来的组件与客户端展示出来的布局效果不一致，前后端接口界面化实现不够细致， 连基本的顺序调用都无法满足，对于丰富组件方面没有一个很好的认知，不区分 ui 组件和业务组件，在该平台布道时没有一个布道人，也没有培训过程，只是单纯的提供文档，而且没有很好的使用技术为业务赋能，为了实现组件而实现，无法覆盖当前公司所需的普遍性场景与独特性场景，但出现无法满足时只能修改底层代码来达到目标，对于不懂庞大的底层逻辑的开发者，就是一个头皮炸裂的体验感

1、应该在有架构逻辑后考虑使用者的易用性与扩展性，能在能力边界范围内直接从上层满足大部分的开发，而特殊性的场景开发能在不触碰底层前提下有好的解决方案
2、丰富的文档，需要布道者规划详细的培训计划，让开发者懂得如何使用与目前不满足的方面如何解决，还有不适用方面，还有未来的展望

软通动力
B 端业务流程复杂切业务线长的填表型产品，为了解决移动的工作人员在寻找有意向客户与已有的客户快捷线上完成调查和合同填写，让流程从线下的需要多人处理转变为线上的快捷处理的产品，而由于都是一类有共同业务性质的产品，项目的实现是一套产品模板代码动态生成各种所需的产品，核心在于动态表单，技术难点在于它能支持脚本的配置执行，因为表单的操作还是会有产品所独特的业务逻辑，但这些都是前人已经搭建好的了，主要是怎么在这套基础上添加更加灵活扩展的能力，还有解决大表单性能问题，由于动态表单是基于 antdesign 的表单方案实现的表单配置化配套组件，但它有个缺点，就是大表单情况下会卡顿，这是因为每次表单项的触发都会触发所有表单项渲染导致的，我们针对这个进行了考察与权衡后决定在不改变之前表单配置化配套组件前提下在内部进行表单分组操作来解决实现表单操作卡顿问题，如何实现，就是配置化组件与 antdesign 的表单之间添加一层组件进行组的收集与查找，达到上层组件变化无感知，对于灵活扩展的能力方面，主要是表单外无法控制表单内的脚本业务代码，在外部触发场景里，实现困难，解决方案是利用发布订阅的设计模式，收集每个表单项，然后外部根据表单项唯一标识找到对应的表单进行触发

由于表单配置化配套组件的稳定性与封装性很重要，而项目是由多个小组进行开发，所以另起了一个组件库项目，把配置化的组件都移入，增强对这部分的修改成本，还有就是组件库的引入，可以大大提供组件的复用性，减少低效的开发，而目前组件库是一个组件一个文件夹，使用按需加载的模式，开发、开发规范、预览 docz、打包、单元测试、发布、指令化如组件模块生成，缩短打包流程、发布流程、代码检查的 git hooks 检查、更好的 link 调试方式

架构
难点：如何接手一个没有任何规范，目录架构混乱，数据流方式冗余多样化，开发体验极差，代码复用很差的项目

首先了解项目背景，是 pc 端项目的 app 版，然后了解项目并根据问题难度与轻缓进行排序，根据业务的情况，处理顺序是目录架构混乱=》没有任何规范=》代码复用很差=》开发体验极差=》数据流方式冗余多样化

1、目录架构混乱
思考点，在不变化现有的打包策略的方式，进行内部的调整，决定使用微模块化，另起模块目录，对现有的目录进行渐进式调整与迁移，好处可以像新起项目一样进行策划
而且它的能力与微前端类似，有良好的扩展性与部署能力，能很好的应对未来的变化

2、引入 eslint，并只对新起目录进行开发时的校验报错，然后 git hooks 也加入 eslint 与 prettier，对于所有提交的代码进行检查，然后在 CI 时也把 eslint 加入做最后一层的检查，当然还有 typescript 的开启，使用的是逐步迁移模式

3、分析项目中频繁使用的，如请求，方法，组件，由于项目已经使用了 typescript 了，首先解决请求，因为这个是前后端交接处，一份好的接口定义，可以省去不必要的沟通与查找成本，然后是创建公共模块与公共组件模块，这是每个模块的复用代码，然后在公共代码丰富后集成文档库，实现预览与使用说明，提高开发效率

4、分析 webpack 配置，减少 webpack 的搜索范围，而对于代码检查之类的都使用 pulgin，因为 loader 是单线程执行的，把稳定的包抽取出来放到 CDN，然后 externals 里排除，babel 的缓存开启，happypack 开启 loader 多线程，使用 webpack 热加载与 react 热加载，根据路由进行代码分割，如果有必要可以调整代码分割的策略，然后代码的压缩与 sourceMap 的模式都会严重影响构建速度

5、数据流方面只能提倡在数据传输不复杂的情况下，直接让组件间进行传输，有必要就使用 redux 进行数据传输，当然特殊情况可以使用别的

兼容性问题

react 生命周期

挂载时
constructor
getDerivedStateFromProps 即 state 的值取决于 props
render
componentDidMount

更新时
getDerivedStateFromProps
shouldComponentUpdate
render
getSnapshotBeforeUpdate
componentDidUpdate

卸载时
componentWillUnmount

纯函数 无副作用
就是入参与出参一致

componentWillReceiveProps

interface
type

都可以描述对象或者函数
都允许拓展 只是方式不一样 extends &

type 基本类型，联合类型，元组等

interface 声明合并
